import * as Path from "path";
import { interpolationRegex } from "../translation-utils";
import { languages, Shortcode } from "../translations/languages";
import { Language } from "../types/language.interface";
import {
  ArgTranslation,
  isArgTranslation,
  isStringTranslation,
  Translation,
  Translations
} from "../types/translations";
import {
  childFiles,
  childFolders,
  createFolder,
  delFolder,
  folderExists,
  writeFile
} from "./file-utils";
import { logDoneSection, logError, logInfo, logSection } from "./log";
import { SectionDetails } from "./section-details";

const projDir: string = Path.join(__dirname, "../../");
const srcDir: string = Path.join(projDir, "./src");
const translationsDir: string = Path.join(srcDir, "./translations");
const valuesDir: string = Path.join(srcDir, "./values");

let engbFullTranslations: Translation | Translations;
let engbFullSections: SectionDetails[];

async function run(): Promise<void> {
  logSection("Cleaning values folder");
  await delFolder(valuesDir);
  await createFolder(valuesDir);

  const foundLanguageNames: Set<string> = new Set<string>();

  for (const shortcode of Object.keys(languages) as Shortcode[]) {
    const language: Language<Shortcode> = languages[shortcode];

    if (!language.name) {
      logError(`Language ${shortcode} needs a name`);
    }

    if (foundLanguageNames.has(language.name)) {
      logError(
        `Language ${shortcode} needs a distinct name, but ${language.name} has already been used.`
      );
    }

    foundLanguageNames.add(language.name);

    if (!language.extends && shortcode !== "en-gb") {
      logError(`Language ${shortcode} needs to extend an other language`);
    }

    await loadLanguage(shortcode as Shortcode, language.name, language.extends);
  }
}

async function loadLanguage(shortcode: Shortcode, name: string, parent: Shortcode): Promise<void> {
  logSection(`Loading ${shortcode}, ${name}, which extends ${parent}`);

  const shortcodeNoDash: string = shortcode.split("-").join("");
  const parentShortcodeNoDash: string = parent?.split("-").join("");
  const baseFolder: string = Path.join(translationsDir, `./${shortcode}`);

  let currentFile: string = `// ********************************
// This file is generated by a tool
// ********************************

import { interpolate } from "../translation-utils";
import { ILanguage } from "./language.interface";
import * as Sections from "./sections.interface";
${!parent ? "" : `import * as ${parentShortcodeNoDash} from "./${parent}";\n`}
// Sections
`;

  let sections: SectionDetails[] = [];

  if (await folderExists(baseFolder)) {
    sections = await loadLanguageFolder(baseFolder, new SectionDetails(), parent);
  }

  for (const section of sections) {
    currentFile += `\nexport const ${section.varName}: Sections.${section.interfaceName} = {\n`;
    currentFile += section.text;
    currentFile += "};\n";
  }

  if (shortcode === "en-gb") {
    engbFullSections = sections;
  }

  currentFile += `
// Language

export const ${shortcodeNoDash}: ILanguage = {
  metadata: {
    shortcode: "${shortcode}",
    name: "${name}"
  },${engbFullSections.map(
    (s, i) => `\n  "${s.key}": ${sections[i]?.varName ?? `${parentShortcodeNoDash}.${s.varName}`},`
  )}
};

export default ${shortcodeNoDash};
`;

  await writeFile(Path.join(valuesDir, shortcode + ".ts"), currentFile);

  logDoneSection(`Loading ${shortcode}, ${name}, which extends ${parent}`);

  if (shortcode === "en-gb") {
    logSection(`Writing Section and Language files as the current shortcode is en-gb`);
    await writeSectionFile(sections);
    await writeLanguageFile(sections);
    logDoneSection(`Writing Section and Language files as the current shortcode is en-gb`);
  }
}

async function writeSectionFile(sections: SectionDetails[]): Promise<void> {
  let sectionFile: string = `// ********************************
// This file is generated by a tool
// ********************************

import { StringTranslation } from "../types/translations";

// Sections
`;

  for (const section of sections) {
    sectionFile += `
export interface ${section.interfaceName} {
${section.interfaceText}}
`;

    await writeFile(Path.join(valuesDir, "sections.interface.ts"), sectionFile);
  }
}

async function writeLanguageFile(sections: SectionDetails[]): Promise<void> {
  const sectionFile: string = `// ********************************
// This file is generated by a tool
// ********************************

import { ILanguageMetadata } from "../types/language-metadata.interface";
import * as Sections from "./sections.interface";

// Language

export interface ILanguage {
  metadata: ILanguageMetadata;
${sections.map(s => `  "${s.key}": Sections.${s.interfaceName};\n`)}}
`;

  await writeFile(Path.join(valuesDir, "language.interface.ts"), sectionFile);
}

async function loadLanguageFolder(
  parentPath: string,
  sectionDetails: SectionDetails,
  parent: Shortcode
): Promise<SectionDetails[]> {
  const childSectionDetails: SectionDetails[] = [];

  const folders: string[] = await childFolders(parentPath);
  for (const folder of folders) {
    const folderPath: string = Path.join(parentPath, folder);
    const newSectionDetails: SectionDetails = sectionDetails.copy();
    newSectionDetails.add(folder);

    childSectionDetails.push(...(await loadLanguageFolder(folderPath, newSectionDetails, parent)));
  }

  const files: string[] = await childFiles(parentPath);
  for (const file of files) {
    const filePath: string = Path.join(parentPath, file);
    const fileNameWithoutExtension: string = Path.parse(file).name;
    const newSectionDetails: SectionDetails = sectionDetails.copy();
    newSectionDetails.add(fileNameWithoutExtension);

    childSectionDetails.push(await loadLanguageFile(filePath, newSectionDetails, parent));
  }

  return childSectionDetails;
}

async function loadLanguageFile(
  path: string,
  sectionDetails: SectionDetails,
  parent: Shortcode
): Promise<SectionDetails> {
  logInfo(`Loading file ${Path.relative(translationsDir, path)}`);

  const loadedModule: any = await import(path);
  const translations: Translations = loadedModule.translations;

  if (!translations) {
    logError(`No translations found in the file ${path}`);
  }

  if (!parent) {
    engbFullTranslations = translations;
  }

  sectionDetails = loadObject(
    sectionDetails,
    translations,
    "",
    0,
    !parent ? undefined : engbFullTranslations,
    parent
  );

  return sectionDetails;
}

function loadObject(
  sectionDetails: SectionDetails,
  value: Translation | Translations,
  key: string,
  indentLevel: number,
  engbTranslations: Translation | Translations | undefined,
  parent: Shortcode
): SectionDetails {
  const indent: string = "  ".repeat(indentLevel);

  if (!value) {
    const parentShortcodeNoDash: string = parent?.split("-").join("");
    sectionDetails.text += `${indent}${key}: ${parentShortcodeNoDash}.${sectionDetails.varName}.${key},\n`;
    return sectionDetails;
  }

  if (isStringTranslation(value)) {
    if (key.length === 0) {
      logError("Found a top-level string value");
    }
    sectionDetails.text += `${indent}${key}: "${value}",\n`;
    sectionDetails.interfaceText += `${indent}${key}: StringTranslation;\n`;
    return sectionDetails;
  }

  if (isArgTranslation(value)) {
    validateArgTranslation(value);

    const parameters: string = value.args?.map(v => `${v}: string`).join(", ") ?? "";
    const args: string = value.args?.join(", ") ?? "";

    sectionDetails.text += `${indent}${key}: (${parameters}) => interpolate("${value.value}", { ${args} }),\n`;
    sectionDetails.interfaceText += `${indent}${key}: (${parameters}) => string;\n`;
    return sectionDetails;
  }

  if (!!key && key.length > 0) {
    sectionDetails.text += `${indent}${key}: {\n`;
    sectionDetails.interfaceText += `${indent}${key}: {\n`;
  }

  const keys: string[] = Object.keys(engbTranslations ?? value);
  for (const childKey of keys) {
    const childEngbTranslations: Translations = !!engbTranslations
      ? ((engbTranslations as any)[childKey] as Translations)
      : ((value as any)[childKey] as Translations);

    sectionDetails = loadObject(
      sectionDetails,
      (value as any)[childKey] as Translations,
      childKey,
      indentLevel + 1,
      childEngbTranslations,
      parent
    );
  }

  if (!!key && key.length > 0) {
    sectionDetails.text += `${indent}},\n`;
    sectionDetails.interfaceText += `${indent}};\n`;
  }

  return sectionDetails;
}

function validateArgTranslation(translation: ArgTranslation): void {
  const valuesToInterpolate: string[] =
    translation.value.match(interpolationRegex)?.map(m => m.substr(2, m.length - 3)) ?? [];

  if (valuesToInterpolate.length > 0 && !translation.args) {
    logError(
      `No translation args were given for "${
        translation.value
      }" but interpolation variables were found: ${valuesToInterpolate
        .map(v => `"${v}"`)
        .join(", ")}`
    );
  }

  const args: string[] = translation.args ?? [];

  for (const value of valuesToInterpolate) {
    if (value === "") {
      logError(
        `The translation "${translation.value}" contains an empty interpolation variable ("\${}")`
      );
    }

    if (!args.includes(value)) {
      logError(
        `The translation "${translation.value}" requires a value for ${value} but it was not declared as an argument`
      );
    }
  }
}

(async () => await run())();
